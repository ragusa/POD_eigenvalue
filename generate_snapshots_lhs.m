function generate_snapshots_lhs(n_snapshots,filename)
% Generates n_snapshots using region-dependent FEM matrices (previously
% computed using deal.ii)
% Each snapshot is generated by perturbing the nominal cross-section values
% using Latin Hypercube Sampling
% Each sanpshot (eigenvalue,eigenvector) and ts associated perturbed cross-
% section database is stored in the user-supplied filename

close all;  clc;

fprintf('Generating %d snapshots and saving them in %s \n\n\n',n_snapshots,filename);

if nargin ~= 2
    error('Two arguments (number of snapshots and filename where to save them) must be provided');
else
    if ~ischar(filename)
        error('Second argument (filename) must be a string');
    end
end

% loads:
%    m: number of materials
%    n: number of unknowns (all groups)
%    nnz_: number of nonzeros in the final group-wise matrix
%    R: Robin boundary condition matrix (1 matrix)
%    M: mass matrix per unit cross section, per material (m matrices)
%    S: stiffmess matrix per unit cross section, per material (m matrices)
load FEM_matrices.mat;
% load FEM_matrices_ref1.mat;

% loads:
%    xs: benchmark cross section (nominal values)
load nominal_xs.mat

% allocate memory
eigenvect=zeros(2*n,n_snapshots);
lambda=zeros(n_snapshots,1);

% prepare pertubations
frac_pert = 0.2; % 20% perturbation for each nominal value
nominal=[];
for imat=1:length(xs)
    % get diffusion coefficients
    nominal(end+1:end+2)=xs{imat}.cdif;
    % get removal XS
    nominal(end+1:end+2)=xs{imat}.sigr;
    % compute siga_1 (we want to perturb only siga, not sigr, to make sure
    % sigr>=0
    nominal(end-1)=nominal(end-1)-xs{imat}.sigs;    
    % get sigs 1->2
    nominal(end+1)=xs{imat}.sigs;
    if(imat>1)&&(imat<5)
        % get nu.sigfission
        nominal(end+1)=xs{imat}.sigf(2);
    end
end
dim_pert = length(nominal);
pert_min=(1-frac_pert)*nominal';
pert_max=(1+frac_pert)*nominal';

% latin hypercube sampling
pSamplesLHS = pert_min*ones(1,n_snapshots) + lhsdesign(n_snapshots,dim_pert)'.*((pert_max-pert_min)*ones(1,n_snapshots));

% loop over snapshots
for i=1:n_snapshots
    % create perturbed xs database
    counter=0;
    for imat=1:length(xs)
        xs{imat}.cdif= pSamplesLHS(counter+[1:2],i)';
        xs{imat}.sigr= pSamplesLHS(counter+[3:4],i)';
        xs{imat}.sigs= pSamplesLHS(counter+5  ,i);
        % reconstruct sigr_1 because we sampled siga_1 and sigs_{1->2}
        xs{imat}.sigr(1)=xs{imat}.sigr(1)+xs{imat}.sigs;
        % sanity check (we shold never go here)
        if(xs{imat}.sigr(1)<xs{imat}.sigs)
            fprintf('snaphot %d, material %d, sigr1 %d too small compared to sigs %d\n',i,imat,xs{imat}.sigr(1),xs{imat}.sigs);
            warning('unphysical case');
        end
        if(imat>1)&&(imat<5)
            xs{imat}.sigf(2)= pSamplesLHS(counter+6  ,i);
            counter=counter+6;
        else
            counter=counter+5;
        end
    end
    % build full system system matrix usng xs database
    [A,B]=build_full_system_matrix(m,n,nnz_,R,M,S,xs);
    [eigenvect(:,i),lambda(i)]=eigs(B,A,1); % ,'LM',opts);
    fprintf('Snapshot %d/%d: Keff=%g\n',i,n_snapshots,lambda(i));
    % save the xs database for reproductibility of the results
    db{i}=xs;
end

% save snapshot values
save(filename,'eigenvect','lambda','db');

return
end
